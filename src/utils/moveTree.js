/**
 * Move tree computation for the combinatorial p3 loops editor.
 * 
 * This module computes a tree of possible move sequences up to a given depth,
 * collapsing consecutive moves with no decision point into single segments.
 * 
 * The wallpaper group P3 is generated by:
 * - Two translation generators (forming a lattice)
 * - A 3-fold rotation (order 3: rotation by 120°)
 * 
 * Each rhombus position is indexed by (tx, ty, r) where:
 * - tx, ty are integer translation coordinates
 * - r is 0, 1, or 2 representing 0°, 120°, or 240° rotation
 * 
 * Starting rhombus is at (0, 0, 0).
 */

import { 
  getValidSegments, 
  getNextStartPoint, 
  addEdgeToSegment,
  canCloseLoop
} from './combinatorialPathLogic.js';
import { getIdentifiedSide } from './geometry.js';

/**
 * @typedef {Object} WallpaperIndex
 * @property {number} tx - Translation in first direction
 * @property {number} ty - Translation in second direction  
 * @property {number} r - Rotation index: 0, 1, or 2 (representing 0°, 120°, 240°)
 */

/**
 * @typedef {Object} MoveTreeNode
 * @property {Object} segment - The segment this move goes to
 * @property {Object|null} newState - State after this move
 * @property {boolean} isCloseLoop - True if this is a loop closing move
 * @property {WallpaperIndex} wallpaperIndex - Wallpaper group coordinates
 * @property {MoveTreeNode[]} children - Child nodes (subsequent moves)
 * @property {boolean} isLeaf - True if this is a leaf node
 */

/**
 * Create the identity wallpaper index (starting position).
 * @returns {WallpaperIndex}
 */
export function createIdentityWallpaperIndex() {
  return { tx: 0, ty: 0, r: 0 };
}

/**
 * Update the wallpaper index when crossing through a side.
 * 
 * Crossing rules (based on which corner the rotation is around):
 * - north: 120° CW around NE → rotation decreases by 1 (mod 3)
 * - east: 120° CCW around NE → rotation increases by 1 (mod 3)
 * - south: 120° CW around SW → rotation decreases by 1 (mod 3)
 * - west: 120° CCW around SW → rotation increases by 1 (mod 3)
 * 
 * Translations happen when the rotation wraps around:
 * The translation vectors depend on the current rotation state.
 * 
 * @param {'north' | 'east' | 'south' | 'west'} side - Side being crossed
 * @param {WallpaperIndex} current - Current wallpaper index
 * @returns {WallpaperIndex} - New wallpaper index
 */
export function updateWallpaperIndex(side, current) {
  const { tx, ty, r } = current;
  
  // Rotation changes based on crossing direction
  // CW (-1 mod 3): north, south
  // CCW (+1 mod 3): east, west
  let newR;
  let deltaTx = 0;
  let deltaTy = 0;
  
  switch (side) {
    case 'north':
      newR = (r + 2) % 3; // -1 mod 3 = +2 mod 3
      // Translation adjustment depends on the corner (NE)
      // When rotating CW around NE corner
      if (r === 0) {
        // From r=0 to r=2: translation changes
        deltaTx = 0;
        deltaTy = 1;
      } else if (r === 1) {
        deltaTx = -1;
        deltaTy = 0;
      } else { // r === 2
        deltaTx = 1;
        deltaTy = -1;
      }
      break;
      
    case 'east':
      newR = (r + 1) % 3;
      // Rotation CCW around NE corner
      if (r === 0) {
        deltaTx = 1;
        deltaTy = 0;
      } else if (r === 1) {
        deltaTx = -1;
        deltaTy = 1;
      } else { // r === 2
        deltaTx = 0;
        deltaTy = -1;
      }
      break;
      
    case 'south':
      newR = (r + 2) % 3; // -1 mod 3
      // Rotation CW around SW corner
      if (r === 0) {
        deltaTx = 0;
        deltaTy = -1;
      } else if (r === 1) {
        deltaTx = 1;
        deltaTy = 0;
      } else { // r === 2
        deltaTx = -1;
        deltaTy = 1;
      }
      break;
      
    case 'west':
      newR = (r + 1) % 3;
      // Rotation CCW around SW corner
      if (r === 0) {
        deltaTx = -1;
        deltaTy = 0;
      } else if (r === 1) {
        deltaTx = 1;
        deltaTy = -1;
      } else { // r === 2
        deltaTx = 0;
        deltaTy = 1;
      }
      break;
      
    default:
      throw new Error(`Unknown side: ${side}`);
  }
  
  return {
    tx: tx + deltaTx,
    ty: ty + deltaTy,
    r: newR
  };
}

/**
 * Determine if crossing from one point to another changes the rhombus.
 * An edge stays in the same rhombus if:
 * 1. Both points are on the same side
 * 2. Both points are on identified sides with the same position
 * 
 * @param {Object} fromPoint - Starting point { side, pos }
 * @param {Object} toPoint - Ending point { side, pos }
 * @returns {boolean} - True if this edge crosses to a new rhombus
 */
function edgeCrossesRhombus(fromPoint, toPoint) {
  // Same side = stays in same rhombus
  if (fromPoint.side === toPoint.side) {
    return false;
  }
  
  // Identified sides at same position = stays in same rhombus
  if (getIdentifiedSide(fromPoint.side) === toPoint.side && 
      fromPoint.pos === toPoint.pos) {
    return false;
  }
  
  return true;
}

/**
 * Compute the wallpaper index for the destination of an edge.
 * 
 * @param {Object} edge - Edge { from, to }
 * @param {WallpaperIndex} currentIndex - Current wallpaper index
 * @returns {WallpaperIndex} - Wallpaper index at destination
 */
export function computeEdgeDestinationIndex(edge, currentIndex) {
  // If the edge doesn't cross the rhombus boundary, index stays same
  if (!edgeCrossesRhombus(edge.from, edge.to)) {
    return currentIndex;
  }
  
  // Otherwise, update based on the side we exit through
  return updateWallpaperIndex(edge.to.side, currentIndex);
}

/**
 * Format a wallpaper index as a string.
 * @param {WallpaperIndex} index
 * @returns {string}
 */
export function formatWallpaperIndex(index) {
  const rotLabel = ['0°', '120°', '240°'][index.r];
  return `(${index.tx}, ${index.ty}, ${rotLabel})`;
}

/**
 * Compute the move tree from the current state.
 * 
 * The tree collapses consecutive moves with no decision point into single segments.
 * A "decision point" is where there are 2+ valid moves, or where loop closing is possible.
 * 
 * @param {Object} state - Current combinatorial state
 * @param {number} maxDepth - Maximum depth to explore (number of decision points)
 * @param {WallpaperIndex} [startIndex] - Starting wallpaper index (defaults to identity)
 * @returns {MoveTreeNode[]} - Array of possible move sequences from current position
 */
export function computeMoveTree(state, maxDepth, startIndex = null) {
  if (maxDepth <= 0) {
    return [];
  }
  
  const currentIndex = startIndex || createIdentityWallpaperIndex();
  const startPoint = getNextStartPoint(state);
  
  if (!startPoint) {
    return [];
  }
  
  // Get all valid segments from current position
  const validSegments = getValidSegments(state, startPoint);
  
  // Check if loop can be closed (this is also a choice)
  const closeLoopResult = canCloseLoop(state);
  
  const nodes = [];
  
  // Add loop closing option if available
  if (closeLoopResult.canClose) {
    const closingEdge = closeLoopResult.closingEdge;
    
    // Compute destination wallpaper index for the closing edge
    const destIndex = computeEdgeDestinationIndex(closingEdge, currentIndex);
    
    nodes.push({
      segment: null,
      edge: closingEdge,
      newState: null, // Loop is closed, no further moves
      isCloseLoop: true,
      wallpaperIndex: destIndex,
      children: [],
      isLeaf: true,
      description: 'Close Loop'
    });
  }
  
  // Process each valid segment
  for (const segment of validSegments) {
    const result = addEdgeToSegment(state, startPoint, segment);
    
    if (result.error) {
      continue; // Skip if there's an error (shouldn't happen with valid segments)
    }
    
    const newState = result.newState;
    const newEdge = newState.edges[newState.edges.length - 1];
    
    // Compute destination wallpaper index
    const destIndex = computeEdgeDestinationIndex(newEdge, currentIndex);
    
    // Now explore from this new state to find the next decision point
    const expandedResult = expandToNextDecisionPoint(newState, destIndex, maxDepth - 1, [segment]);
    
    nodes.push(expandedResult);
  }
  
  return nodes;
}

// Maximum number of forced moves to follow before stopping
const MAX_FORCED_MOVES = 100;

/**
 * Expand from a state until we reach a decision point or max depth.
 * A decision point is where:
 * - There are 2+ valid moves (including loop close), OR
 * - Loop can be closed (counts as an extra option)
 * 
 * This function collapses linear sequences of forced moves into a single node.
 * 
 * @param {Object} state - Current state
 * @param {WallpaperIndex} currentIndex - Current wallpaper index
 * @param {number} remainingDepth - Remaining depth to explore
 * @param {Object[]} pathSegments - Segments accumulated on the path to here
 * @param {number} [forcedMoveCount=0] - Counter to prevent infinite loops
 * @returns {MoveTreeNode}
 */
function expandToNextDecisionPoint(state, currentIndex, remainingDepth, pathSegments, forcedMoveCount = 0) {
  // Safety check to prevent infinite loops
  if (forcedMoveCount >= MAX_FORCED_MOVES) {
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments) + ' (max depth)'
    };
  }
  
  const startPoint = getNextStartPoint(state);
  
  if (!startPoint) {
    // No more moves possible
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments)
    };
  }
  
  const validSegments = getValidSegments(state, startPoint);
  const closeLoopResult = canCloseLoop(state);
  
  // Count total options
  const numOptions = validSegments.length + (closeLoopResult.canClose ? 1 : 0);
  
  // If there's a decision point (more than 1 option), stop here
  if (numOptions !== 1) {
    // This is a decision point
    if (remainingDepth <= 0 || numOptions === 0) {
      // Max depth reached or dead end
      return {
        segments: pathSegments,
        newState: state,
        isCloseLoop: false,
        wallpaperIndex: currentIndex,
        children: [],
        isLeaf: true,
        description: formatPathDescription(pathSegments)
      };
    }
    
    // Recursively compute children
    const children = computeMoveTree(state, remainingDepth, currentIndex);
    
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children,
      isLeaf: children.length === 0,
      description: formatPathDescription(pathSegments)
    };
  }
  
  // Only one option - follow it (collapse into this segment)
  if (closeLoopResult.canClose) {
    // The only option is to close the loop
    const closingEdge = closeLoopResult.closingEdge;
    const destIndex = computeEdgeDestinationIndex(closingEdge, currentIndex);
    
    return {
      segments: pathSegments,
      newState: null,
      isCloseLoop: true,
      wallpaperIndex: destIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments) + ' → Close Loop'
    };
  }
  
  // The only option is the single valid segment
  const segment = validSegments[0];
  const result = addEdgeToSegment(state, startPoint, segment);
  
  if (result.error) {
    // Error shouldn't happen, but handle gracefully
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments)
    };
  }
  
  const newState = result.newState;
  const newEdge = newState.edges[newState.edges.length - 1];
  const destIndex = computeEdgeDestinationIndex(newEdge, currentIndex);
  
  // Continue following the forced path
  return expandToNextDecisionPoint(
    newState, 
    destIndex, 
    remainingDepth, 
    [...pathSegments, segment],
    forcedMoveCount + 1
  );
}

/**
 * Format a description for a path of segments.
 * @param {Object[]} segments - Array of segments
 * @returns {string}
 */
function formatPathDescription(segments) {
  if (segments.length === 0) {
    return 'No moves';
  }
  
  if (segments.length === 1) {
    return formatSegmentDescription(segments[0]);
  }
  
  return segments.map(formatSegmentDescription).join(' → ');
}

/**
 * Format a description for a single segment.
 * @param {Object} segment - Segment { side, startPos, endPos }
 * @returns {string}
 */
function formatSegmentDescription(segment) {
  const side = segment.side.charAt(0).toUpperCase() + segment.side.slice(1);
  
  if (segment.startPos === null && segment.endPos === null) {
    return `${side} (entire)`;
  } else if (segment.startPos === null) {
    return `${side} (before pt ${segment.endPos + 1})`;
  } else if (segment.endPos === null) {
    return `${side} (after pt ${segment.startPos + 1})`;
  } else {
    return `${side} (pts ${segment.startPos + 1}–${segment.endPos + 1})`;
  }
}

/**
 * Convert the move tree to a flat structure for rendering.
 * Each item includes the path to that node and its depth.
 * 
 * @param {MoveTreeNode[]} tree - The move tree
 * @param {number} [depth=0] - Current depth
 * @returns {Array<{node: MoveTreeNode, depth: number, path: string[]}>}
 */
export function flattenMoveTree(tree, depth = 0) {
  const result = [];
  
  for (const node of tree) {
    result.push({ node, depth });
    
    if (node.children && node.children.length > 0) {
      result.push(...flattenMoveTree(node.children, depth + 1));
    }
  }
  
  return result;
}
