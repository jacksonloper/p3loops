/**
 * Move tree computation for the combinatorial p3 loops editor.
 * 
 * This module computes a tree of possible move sequences up to a given depth,
 * collapsing consecutive moves with no decision point into single segments.
 * 
 * The wallpaper group P3 is generated by:
 * - Two translation generators T1, T2 (forming a hexagonal lattice)
 * - A 3-fold rotation R (120° counter-clockwise around origin)
 * 
 * Any rhombus position is represented by a 2D affine transform that can be
 * factored as T1^i * T2^j * R^k where:
 * - i, j are integer translation indices
 * - k is 0, 1, or 2 representing 0°, 120°, or 240° rotation
 * 
 * The index (i, j, k) uniquely identifies each rhombus copy.
 * Geometrically: (i, j) indexes hexagons, k indexes the 3 rhombi within each hexagon.
 * 
 * Starting rhombus is at (0, 0, 0).
 */

import { 
  getValidSegments, 
  getNextStartPoint, 
  addEdgeToSegment,
  canCloseLoop
} from './combinatorialPathLogic.js';
import { getIdentifiedSide } from './geometry.js';

// ============================================================================
// P3 GROUP GEOMETRY CONSTANTS
// ============================================================================

const SIDE = 300;
const ANGLE_120 = 2 * Math.PI / 3;
const COS_120 = Math.cos(ANGLE_120);
const SIN_120 = Math.sin(ANGLE_120);

// Tolerance for comparing float edge positions (t values)
const FLOAT_POSITION_TOLERANCE = 0.001;

// Rhombus corners (same as wallpaperGeometry.js)
const NE_CORNER = { x: 0, y: 0 };
const NW_CORNER = { x: -SIDE, y: 0 };
const EAST_ANGLE = -60 * Math.PI / 180;
const SE_CORNER = { x: SIDE * Math.cos(EAST_ANGLE), y: SIDE * Math.sin(EAST_ANGLE) };
const SW_CORNER = { x: NW_CORNER.x + SE_CORNER.x, y: NW_CORNER.y + SE_CORNER.y };

// Base rhombus centroid (center point)
const BASE_CENTROID = {
  x: (NE_CORNER.x + NW_CORNER.x + SE_CORNER.x + SW_CORNER.x) / 4,
  y: (NE_CORNER.y + NW_CORNER.y + SE_CORNER.y + SW_CORNER.y) / 4
};

// Translation generators for P3 hexagonal lattice (from reference Python code)
// These are the offsets between adjacent hexagon centers in axial coordinates
// T1 = q-step: moves to adjacent hex in "q" direction
// T2 = r-step: moves to adjacent hex in "r" direction
const SQRT3 = Math.sqrt(3);
const T1 = { x: 1.5 * SIDE, y: (SQRT3 / 2) * SIDE };   // [1.5*s, sqrt(3)/2*s]
const T2 = { x: 0, y: SQRT3 * SIDE };                   // [0, sqrt(3)*s]

// Determinant of [T1 T2] matrix for solving linear system
const T_DET = T1.x * T2.y - T2.x * T1.y;

/**
 * @typedef {Object} WallpaperIndex
 * @property {number} tx - Translation in first direction (i)
 * @property {number} ty - Translation in second direction (j)
 * @property {number} r - Rotation index: 0, 1, or 2 (k)
 */

/**
 * @typedef {Object} AffineFrame
 * @property {number} a - Rotation matrix element
 * @property {number} b - Rotation matrix element
 * @property {number} c - Rotation matrix element
 * @property {number} d - Rotation matrix element
 * @property {number} tx - Translation x
 * @property {number} ty - Translation y
 */

/**
 * @typedef {Object} MoveTreeNode
 * @property {Object} segment - The segment this move goes to
 * @property {Object|null} newState - State after this move
 * @property {boolean} isCloseLoop - True if this is a loop closing move
 * @property {WallpaperIndex} wallpaperIndex - Wallpaper group coordinates
 * @property {MoveTreeNode[]} children - Child nodes (subsequent moves)
 * @property {boolean} isLeaf - True if this is a leaf node
 */

// ============================================================================
// AFFINE FRAME OPERATIONS
// ============================================================================

/**
 * Create the identity affine frame.
 * @returns {AffineFrame}
 */
export function createIdentityFrame() {
  return { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
}

/**
 * Apply an affine frame to a point.
 * @param {AffineFrame} frame
 * @param {number} x
 * @param {number} y
 * @returns {{ x: number, y: number }}
 */
function applyFrame(frame, x, y) {
  return {
    x: frame.a * x + frame.b * y + frame.tx,
    y: frame.c * x + frame.d * y + frame.ty
  };
}

/**
 * Compose two affine frames: result = second ∘ first
 * @param {AffineFrame} first
 * @param {AffineFrame} second
 * @returns {AffineFrame}
 */
function composeFrames(first, second) {
  return {
    a: second.a * first.a + second.b * first.c,
    b: second.a * first.b + second.b * first.d,
    c: second.c * first.a + second.d * first.c,
    d: second.c * first.b + second.d * first.d,
    tx: second.a * first.tx + second.b * first.ty + second.tx,
    ty: second.c * first.tx + second.d * first.ty + second.ty
  };
}

/**
 * Create a rotation around a point.
 * @param {number} angle - Rotation angle in radians
 * @param {number} cx - Center x
 * @param {number} cy - Center y
 * @returns {AffineFrame}
 */
function rotationAroundPoint(angle, cx, cy) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    a: cos, b: -sin,
    c: sin, d: cos,
    tx: cx - cos * cx + sin * cy,
    ty: cy - sin * cx - cos * cy
  };
}

/**
 * Update an affine frame when crossing through a side.
 * 
 * @param {'north' | 'east' | 'south' | 'west'} side - Side being crossed
 * @param {AffineFrame} currentFrame - Current affine frame
 * @returns {AffineFrame} - New affine frame
 */
export function updateFrameForSide(side, currentFrame) {
  const ANGLE_CW = -ANGLE_120;  // 120° clockwise
  const ANGLE_CCW = ANGLE_120;  // 120° counter-clockwise
  
  let localCorner, angle;
  switch (side) {
    case 'north': localCorner = NE_CORNER; angle = ANGLE_CW; break;
    case 'east':  localCorner = NE_CORNER; angle = ANGLE_CCW; break;
    case 'south': localCorner = SW_CORNER; angle = ANGLE_CW; break;
    case 'west':  localCorner = SW_CORNER; angle = ANGLE_CCW; break;
    default: throw new Error(`Unknown side: ${side}`);
  }
  
  // Transform corner to world space
  const worldCorner = applyFrame(currentFrame, localCorner.x, localCorner.y);
  
  // Create rotation around world-space corner
  const rotation = rotationAroundPoint(angle, worldCorner.x, worldCorner.y);
  
  // Compose: apply current frame first, then rotation
  return composeFrames(currentFrame, rotation);
}

// ============================================================================
// INDEX EXTRACTION
// ============================================================================

/**
 * Extract the rotation index k from an affine frame.
 * The rotation matrix is [a, -b; c, d] where a=cos(θ), c=sin(θ).
 * Using atan2(sin, cos) = atan2(c, a) gives us the rotation angle.
 * @param {AffineFrame} frame
 * @returns {number} - k value: 0, 1, or 2
 */
function extractK(frame) {
  // Extract rotation angle from matrix: atan2(sin(θ), cos(θ)) = atan2(c, a)
  const angle = Math.atan2(frame.c, frame.a);
  const k = Math.round(angle / ANGLE_120);
  return ((k % 3) + 3) % 3; // Normalize to 0, 1, 2
}

/**
 * Solve for translation indices (i, j) from translation vector.
 * Solves: [tx, ty] = i * T1 + j * T2
 * @param {number} tx
 * @param {number} ty
 * @returns {{ i: number, j: number }}
 */
function solveIJ(tx, ty) {
  // Matrix inverse: [i, j]^T = [T1 T2]^-1 * [tx, ty]^T
  // Result is floating-point; round to nearest integer
  const iFloat = (T2.y * tx - T2.x * ty) / T_DET;
  const jFloat = (-T1.y * tx + T1.x * ty) / T_DET;
  return { i: Math.round(iFloat), j: Math.round(jFloat) };
}

/**
 * Apply a rotation by k*120° around the origin.
 * @param {number} x
 * @param {number} y
 * @param {number} k - Rotation index (0, 1, or 2)
 * @returns {{ x: number, y: number }}
 */
function rotateByK(x, y, k) {
  if (k === 0) return { x, y };
  const angle = k * ANGLE_120;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    x: cos * x - sin * y,
    y: sin * x + cos * y
  };
}

/**
 * Extract the wallpaper index (i, j, k) from an affine frame.
 * 
 * The frame represents a transformation that maps the base rhombus to its position.
 * We find (i, j, k) such that T1^i * T2^j * R^k produces the same transformation.
 * 
 * Method:
 * 1. Extract k from the rotation part of the frame
 * 2. Compute where the base rhombus centroid maps to under the frame
 *    (applyFrame applies the affine transformation [a,b,c,d,tx,ty] to a point)
 * 3. Under T1^i * T2^j * R^k, the centroid maps to: i*T1 + j*T2 + R^k(base_centroid)
 * 4. Solve for i, j from: world_centroid - R^k(base_centroid) = i*T1 + j*T2
 * 
 * @param {AffineFrame} frame
 * @returns {WallpaperIndex}
 */
export function extractIndexFromFrame(frame) {
  // Step 1: Extract rotation index k
  const k = extractK(frame);
  
  // Step 2: Apply frame to base centroid to get world-space centroid
  // (applyFrame computes: x' = a*x + b*y + tx, y' = c*x + d*y + ty)
  const worldCentroid = applyFrame(frame, BASE_CENTROID.x, BASE_CENTROID.y);
  
  // Step 3: Compute where R^k would place the base centroid (relative to origin)
  const rotatedBaseCentroid = rotateByK(BASE_CENTROID.x, BASE_CENTROID.y, k);
  
  // Step 4: The translation part is: world_centroid - rotated_base_centroid = i*T1 + j*T2
  const translationX = worldCentroid.x - rotatedBaseCentroid.x;
  const translationY = worldCentroid.y - rotatedBaseCentroid.y;
  
  // Step 5: Solve for i, j
  const { i, j } = solveIJ(translationX, translationY);
  
  return { tx: i, ty: j, r: k };
}

// ============================================================================
// WALLPAPER INDEX API (for compatibility with existing code)
// ============================================================================

/**
 * Create the identity wallpaper index (starting position).
 * @returns {WallpaperIndex}
 */
export function createIdentityWallpaperIndex() {
  return { tx: 0, ty: 0, r: 0 };
}

/**
 * Update the wallpaper index when crossing through a side.
 * Uses pure algebraic rules derived from the P3 group geometry.
 * 
 * The rules depend on:
 * - Which side is crossed (north, east, south, west)
 * - The current rotation state k (0, 1, or 2)
 * 
 * For north/east (rotate around NE corner at origin), only k changes.
 * For south/west (rotate around SW corner), both (i,j) and k change
 * because SW's position depends on k.
 * 
 * @param {'north' | 'east' | 'south' | 'west'} side - Side being crossed
 * @param {WallpaperIndex} current - Current wallpaper index
 * @returns {WallpaperIndex} - New wallpaper index
 */
export function updateWallpaperIndex(side, current) {
  const { tx: i, ty: j, r: k } = current;
  
  switch (side) {
    case 'north':
      // CW rotation around NE (at origin for all k)
      // k: 0→2, 1→0, 2→1 (subtract 1 mod 3)
      return { tx: i, ty: j, r: (k + 2) % 3 };
    
    case 'east':
      // CCW rotation around NE (at origin for all k)
      // k: 0→1, 1→2, 2→0 (add 1 mod 3)
      return { tx: i, ty: j, r: (k + 1) % 3 };
    
    case 'south':
      // CW rotation around SW (position depends on k)
      // k=0: (i,j,0) → (i, j-1, 2)
      // k=1: (i,j,1) → (i+1, j, 0)
      // k=2: (i,j,2) → (i-1, j+1, 1)
      switch (k) {
        case 0: return { tx: i, ty: j - 1, r: 2 };
        case 1: return { tx: i + 1, ty: j, r: 0 };
        case 2: return { tx: i - 1, ty: j + 1, r: 1 };
        default: throw new Error(`Invalid rotation k: ${k}`);
      }
    
    case 'west':
      // CCW rotation around SW (position depends on k)
      // k=0: (i,j,0) → (i-1, j, 1)
      // k=1: (i,j,1) → (i+1, j-1, 2)
      // k=2: (i,j,2) → (i, j+1, 0)
      switch (k) {
        case 0: return { tx: i - 1, ty: j, r: 1 };
        case 1: return { tx: i + 1, ty: j - 1, r: 2 };
        case 2: return { tx: i, ty: j + 1, r: 0 };
        default: throw new Error(`Invalid rotation k: ${k}`);
      }
    
    default:
      throw new Error(`Unknown side: ${side}`);
  }
}

/**
 * Convert a wallpaper index to an affine frame.
 * Computes the transformation T1^i * T2^j * R^k
 * @param {WallpaperIndex} index
 * @returns {AffineFrame}
 */
export function indexToFrame(index) {
  const { tx: i, ty: j, r: k } = index;
  
  // Rotation by k * 120°
  const angle = k * ANGLE_120;
  const cosK = Math.cos(angle);
  const sinK = Math.sin(angle);
  
  // Translation by i*T1 + j*T2
  const translateX = i * T1.x + j * T2.x;
  const translateY = i * T1.y + j * T2.y;
  
  return {
    a: cosK,
    b: -sinK,
    c: sinK,
    d: cosK,
    tx: translateX,
    ty: translateY
  };
}


/**
 * Determine if crossing from one point to another changes the rhombus.
 * An edge stays in the same rhombus if:
 * 1. TO point is interior (edge enters rhombus interior, no boundary crossing)
 * 2. Both points are on the same side
 * 3. Both points are on identified sides with the same position
 * 
 * NOTE: If FROM is interior but TO is a boundary, we DO cross (exit through that side).
 * 
 * Works with both combinatorial edges { side, pos } and float edges { side, t }.
 * 
 * @param {Object} fromPoint - Starting point { side, pos } or { side, t } or { interior: true }
 * @param {Object} toPoint - Ending point { side, pos } or { side, t } or { interior: true }
 * @returns {boolean} - True if this edge crosses to a new rhombus
 */
function edgeCrossesRhombus(fromPoint, toPoint) {
  // If TO is interior, we're entering the interior (no boundary crossing)
  if (toPoint.interior) {
    return false;
  }
  
  // If FROM is interior but TO is boundary, we DO cross (exit through TO side)
  if (fromPoint.interior) {
    return true;
  }
  
  // Same side = stays in same rhombus
  if (fromPoint.side === toPoint.side) {
    return false;
  }
  
  // Check for identified sides at same position
  // Handle both combinatorial (pos) and float (t) edge formats
  if (getIdentifiedSide(fromPoint.side) === toPoint.side) {
    // Float edges use 't', combinatorial edges use 'pos'
    if (fromPoint.t !== undefined && toPoint.t !== undefined) {
      // Float format: compare t values with tolerance
      if (Math.abs(fromPoint.t - toPoint.t) < FLOAT_POSITION_TOLERANCE) {
        return false;
      }
    } else if (fromPoint.pos !== undefined && toPoint.pos !== undefined) {
      // Combinatorial format: compare pos values exactly
      if (fromPoint.pos === toPoint.pos) {
        return false;
      }
    }
    // If one has t and other has pos, they're incompatible - assume crossing
  }
  
  return true;
}

/**
 * Compute the wallpaper index for the destination of an edge.
 * 
 * @param {Object} edge - Edge { from, to }
 * @param {WallpaperIndex} currentIndex - Current wallpaper index
 * @returns {WallpaperIndex} - Wallpaper index at destination
 */
export function computeEdgeDestinationIndex(edge, currentIndex) {
  // If the edge doesn't cross the rhombus boundary, index stays same
  if (!edgeCrossesRhombus(edge.from, edge.to)) {
    return currentIndex;
  }
  
  // Otherwise, update based on the side we exit through
  return updateWallpaperIndex(edge.to.side, currentIndex);
}

/**
 * Format a wallpaper index as a string.
 * @param {WallpaperIndex} index
 * @returns {string}
 */
export function formatWallpaperIndex(index) {
  const rotLabel = ['0°', '120°', '240°'][index.r];
  return `(${index.tx}, ${index.ty}, ${rotLabel})`;
}

/**
 * Compute the wallpaper index for a path by accumulating all edge crossings.
 * Returns the rhombus where the LAST edge is DRAWN (not where we end up after crossing).
 * This matches the visual representation in the wallpaper view.
 * 
 * @param {Object[]} edges - Array of edges in the path (float or combinatorial format)
 * @returns {WallpaperIndex} - Wallpaper index of the rhombus containing the last edge
 */
export function computePathWallpaperIndex(edges) {
  if (edges.length === 0) {
    return createIdentityWallpaperIndex();
  }
  
  let index = createIdentityWallpaperIndex();
  
  // Process all edges EXCEPT the last one
  // After processing edges 0..(n-2), the index is where edge (n-1) is drawn
  for (let i = 0; i < edges.length - 1; i++) {
    const edge = edges[i];
    index = computeEdgeDestinationIndex(edge, index);
  }
  
  // Return the index where the last edge is drawn (before any crossing it causes)
  return index;
}

/**
 * Compute what the wallpaper index would be if an edge to a given side was added.
 * This helps show users how their choice will affect the position.
 * 
 * @param {WallpaperIndex} currentIndex - Current wallpaper index
 * @param {'north' | 'east' | 'south' | 'west'} toSide - Side the edge would go to
 * @returns {WallpaperIndex} - Resulting wallpaper index
 */
export function previewSideChange(currentIndex, toSide) {
  // An edge to a different side will always cross the rhombus
  return updateWallpaperIndex(toSide, currentIndex);
}

/**
 * Compute the move tree from the current state.
 * 
 * The tree collapses consecutive moves with no decision point into single segments.
 * A "decision point" is where there are 2+ valid moves, or where loop closing is possible.
 * 
 * @param {Object} state - Current combinatorial state
 * @param {number} maxDepth - Maximum depth to explore (number of decision points)
 * @param {WallpaperIndex} [startIndex] - Starting wallpaper index (defaults to identity)
 * @returns {MoveTreeNode[]} - Array of possible move sequences from current position
 */
export function computeMoveTree(state, maxDepth, startIndex = null) {
  if (maxDepth <= 0) {
    return [];
  }
  
  const currentIndex = startIndex || createIdentityWallpaperIndex();
  const startPoint = getNextStartPoint(state);
  
  if (!startPoint) {
    return [];
  }
  
  // Get all valid segments from current position
  const validSegments = getValidSegments(state, startPoint);
  
  // Check if loop can be closed (this is also a choice)
  const closeLoopResult = canCloseLoop(state);
  
  const nodes = [];
  
  // Add loop closing option if available
  if (closeLoopResult.canClose) {
    const closingEdge = closeLoopResult.closingEdge;
    
    // Compute destination wallpaper index for the closing edge
    const destIndex = computeEdgeDestinationIndex(closingEdge, currentIndex);
    
    nodes.push({
      segment: null,
      edge: closingEdge,
      newState: null, // Loop is closed, no further moves
      isCloseLoop: true,
      wallpaperIndex: destIndex,
      children: [],
      isLeaf: true,
      description: 'Close Loop'
    });
  }
  
  // Process each valid segment
  for (const segment of validSegments) {
    const result = addEdgeToSegment(state, startPoint, segment);
    
    if (result.error) {
      continue; // Skip if there's an error (shouldn't happen with valid segments)
    }
    
    const newState = result.newState;
    const newEdge = newState.edges[newState.edges.length - 1];
    
    // Compute destination wallpaper index
    const destIndex = computeEdgeDestinationIndex(newEdge, currentIndex);
    
    // Now explore from this new state to find the next decision point
    const expandedResult = expandToNextDecisionPoint(newState, destIndex, maxDepth - 1, [segment]);
    
    nodes.push(expandedResult);
  }
  
  return nodes;
}

// Maximum number of forced moves to follow before stopping
const MAX_FORCED_MOVES = 100;

/**
 * Expand from a state until we reach a decision point or max depth.
 * A decision point is where:
 * - There are 2+ valid moves (including loop close), OR
 * - Loop can be closed (counts as an extra option)
 * 
 * This function collapses linear sequences of forced moves into a single node.
 * 
 * @param {Object} state - Current state
 * @param {WallpaperIndex} currentIndex - Current wallpaper index
 * @param {number} remainingDepth - Remaining depth to explore
 * @param {Object[]} pathSegments - Segments accumulated on the path to here
 * @param {number} [forcedMoveCount=0] - Counter to prevent infinite loops
 * @returns {MoveTreeNode}
 */
function expandToNextDecisionPoint(state, currentIndex, remainingDepth, pathSegments, forcedMoveCount = 0) {
  // Safety check to prevent infinite loops
  if (forcedMoveCount >= MAX_FORCED_MOVES) {
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments) + ' (max depth)'
    };
  }
  
  const startPoint = getNextStartPoint(state);
  
  if (!startPoint) {
    // No more moves possible
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments)
    };
  }
  
  const validSegments = getValidSegments(state, startPoint);
  const closeLoopResult = canCloseLoop(state);
  
  // Count total options
  const numOptions = validSegments.length + (closeLoopResult.canClose ? 1 : 0);
  
  // If there's a decision point (more than 1 option), stop here
  if (numOptions !== 1) {
    // This is a decision point
    if (remainingDepth <= 0 || numOptions === 0) {
      // Max depth reached or dead end
      return {
        segments: pathSegments,
        newState: state,
        isCloseLoop: false,
        wallpaperIndex: currentIndex,
        children: [],
        isLeaf: true,
        description: formatPathDescription(pathSegments)
      };
    }
    
    // Recursively compute children
    const children = computeMoveTree(state, remainingDepth, currentIndex);
    
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children,
      isLeaf: children.length === 0,
      description: formatPathDescription(pathSegments)
    };
  }
  
  // Only one option - follow it (collapse into this segment)
  if (closeLoopResult.canClose) {
    // The only option is to close the loop
    const closingEdge = closeLoopResult.closingEdge;
    const destIndex = computeEdgeDestinationIndex(closingEdge, currentIndex);
    
    return {
      segments: pathSegments,
      newState: null,
      isCloseLoop: true,
      wallpaperIndex: destIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments) + ' → Close Loop'
    };
  }
  
  // The only option is the single valid segment
  const segment = validSegments[0];
  const result = addEdgeToSegment(state, startPoint, segment);
  
  if (result.error) {
    // Error shouldn't happen, but handle gracefully
    return {
      segments: pathSegments,
      newState: state,
      isCloseLoop: false,
      wallpaperIndex: currentIndex,
      children: [],
      isLeaf: true,
      description: formatPathDescription(pathSegments)
    };
  }
  
  const newState = result.newState;
  const newEdge = newState.edges[newState.edges.length - 1];
  const destIndex = computeEdgeDestinationIndex(newEdge, currentIndex);
  
  // Continue following the forced path
  return expandToNextDecisionPoint(
    newState, 
    destIndex, 
    remainingDepth, 
    [...pathSegments, segment],
    forcedMoveCount + 1
  );
}

/**
 * Format a description for a path of segments.
 * @param {Object[]} segments - Array of segments
 * @returns {string}
 */
function formatPathDescription(segments) {
  if (segments.length === 0) {
    return 'No moves';
  }
  
  if (segments.length === 1) {
    return formatSegmentDescription(segments[0]);
  }
  
  return segments.map(formatSegmentDescription).join(' → ');
}

/**
 * Format a description for a single segment.
 * @param {Object} segment - Segment { side, startPos, endPos }
 * @returns {string}
 */
function formatSegmentDescription(segment) {
  const side = segment.side.charAt(0).toUpperCase() + segment.side.slice(1);
  
  if (segment.startPos === null && segment.endPos === null) {
    return `${side} (entire)`;
  } else if (segment.startPos === null) {
    return `${side} (before pt ${segment.endPos + 1})`;
  } else if (segment.endPos === null) {
    return `${side} (after pt ${segment.startPos + 1})`;
  } else {
    return `${side} (pts ${segment.startPos + 1}–${segment.endPos + 1})`;
  }
}

/**
 * Convert the move tree to a flat structure for rendering.
 * Each item includes the path to that node and its depth.
 * 
 * @param {MoveTreeNode[]} tree - The move tree
 * @param {number} [depth=0] - Current depth
 * @returns {Array<{node: MoveTreeNode, depth: number, path: string[]}>}
 */
export function flattenMoveTree(tree, depth = 0) {
  const result = [];
  
  for (const node of tree) {
    result.push({ node, depth });
    
    if (node.children && node.children.length > 0) {
      result.push(...flattenMoveTree(node.children, depth + 1));
    }
  }
  
  return result;
}
